# 链接

## 编译系统

```c
#include <stdio.h>
int main()
{
    printf("hello, world\n");
    return 0;
}
```

编一个hello.c的程序过程如下

![image-20210209184855192](C:\Users\aasus\AppData\Roaming\Typora\typora-user-images\image-20210209184855192.png)

- 预编译阶段：处理以#开头的预处理命令
- 编译阶段：将修改后的源程序文件翻译成汇编程序文件
- 汇编阶段：将汇编文件翻译成可重定位目标文件
- 链接阶段：将可重定位目标文件和printf.o等单独编译好的目标文件进行合并，最终得到可执行目标文件

## 静态链接

输入：一组**可重定位目标文件**

输出：一个完全链接的**可执行目标文件**

链接器主要完成两个任务：

- 符号解析：每个符号代表一个函数、全局变量或者静态变量。目的在于将符号引用和符号定义关联起来
- 重定位：链接器将每个符号定义和一个内存地址关联，然后使所有该符号的引用指向该地址

![image-20210209190501680](C:\Users\aasus\AppData\Roaming\Typora\typora-user-images\image-20210209190501680.png)

## 目标文件

### 可执行目标文件

可以直接在内存中运行

### 可重定位目标文件

可以和其他可重定位目标文件在链接阶段合并成一个可执行目标文件

### 共享目标文件

特殊的可重定位目标文件，可以在运行时被动态地加载进内存并链接

## 动态链接

静态链接存在以下两个问题：

- 静态库更新时，程序需要重新链接
- 对于标准函数库，如printf，静态链接会使每个调用printf的源程序中都有printf的代码，浪费资源

共享库因此被设计出来解决以上问题。在Linux中通常为.so文件，windows中被称为DLL。

- 在给定的文件系统中，一个库只有一个目标文件。所有引用该库的可执行目标文件都共享该文件，不会被复制到可执行目标文件的代码中
- 内存中共享库的.text节(已编译程序的机器代码)的副本可以被不同的正在运行的进程共享。

![image-20210209190724453](C:\Users\aasus\AppData\Roaming\Typora\typora-user-images\image-20210209190724453.png)


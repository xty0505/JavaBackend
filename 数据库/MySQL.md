# MySQL

## 日志

MySQL 日志主要包括错误日志、查询日志、慢查询日志、**事务（redo log 和 undo log）日志和二进制（binlog）**日志。

### binlog

记录数据库的增删改操作的逻辑日志（记录 SQL 语句），以二进制的形式保存在磁盘中。

**使用场景：**

1. 主从复制：在 Master 端开启 binlog，发送到 Slave 端，slave 端重放 binlog 从而同步数据
2. 数据恢复：通过 mysqlbinlog 工具进行恢复

**刷盘时机**：对于 InnoDB 来说，只有在事务提交的时候才会记录 binlog，此时 binlog 在内存中，通过 sync_binlog 参数控制刷盘时机

- 0：不强制要求，由系统判断何时写入
- 1：每次提交都要写入
- N：每 N 个事务才会写入

**日志格式**：

- STATEMENT：基于 SQL 语句的复制，不需要记录每一行的变化，减少了 binlog 的大小，IO次数少，性能较好。某些情况下无法保证主从一致。
- ROW：基于行的复制，记录每条被修改的数据。保证所有修改操作都能被回放，但是导致 binlog 过大。
- MIXED：基于以上两种模式混合。

### redo log

redo log 是 InnoDB 用于保证值持久性的手段，记录事务对数据页进行了哪些修改。 redo log 包含两部分：

- 内容中的日志缓冲： redo log buffer
- 磁盘中的日志文件：redo log file

![image-20210808153649980](..\pic\image-20210808153649980.png)

可以通过 innodb_flush_log_at_trx_commit 参数配置写入磁盘的时机：

- 0延迟写：事务提交时不会将`redo log buffer`中日志写入到`os buffer`，而是每秒写入`os buffer`并调用`fsync()`写入到`redo log file`中。也就是说设置为0时是(大约)每秒刷新写入到磁盘中的，当系统崩溃，会丢失1秒钟的数据。
- 1实时写，实时刷：事务每次提交都会将`redo log buffer`中的日志写入`os buffer`并调用`fsync()`刷到`redo log file`中。这种方式即使系统崩溃也不会丢失任何数据，但是因为每次提交都写入磁盘，IO的性能较差。
- 2实时写，延迟刷： 每次提交都仅写入到`os buffer`，然后是每秒调用`fsync()`将`os buffer`中的日志写入到`redo log file`。

![image-20210808154036020](..\pic\image-20210808154036020.png)

相比与数据页写入磁盘，redo log 写入磁盘效率更高：

- 顺序写入同一个 redo log file中
- redo log IO 数据量远远小于数据页的大小

### undo log

## MySQL索引

索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。

### 四种基本索引结构

#### B+Tree 索引

大多数 MySQL 存储引擎默认的索引类型。

- 由于 B+ Tree 的有序性，还可以用于排序和分组。
- 适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。
- 如果不是按照索引列的顺序进行查找，则无法使用索引。

InnoDB 的 B+ Tree 索引分为主索引和辅助索引。

- 主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。
- 辅助索引的叶子结点的 data 域 记录着主键的值，因此使用辅助索引查找时先找到主键的值， 在去聚簇索引中查找实际数据行。

#### Hash索引

哈希索引能以O(1)的时间复杂度进行查找，但是失去了有序性：

- 无法用于排序与分组
- 只支持精确查找，无法用于部分查找和范围查找

InnoDB 存储引擎有一个特殊的功能叫“**自适应哈希索引**”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

#### 全文索引

MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而非直接比较是否相等

- 查找条件使用 MATCH AGAINST，而不是普通的 WHERE。
- 全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。
- InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。

#### R-Tree

MyISAM 存储引擎支持空间数据索引 R-Tree ，可以用于查询地理数据。

必须使用GIS相关的函数维护数据。

### 索引优化

1.独立的列

不在索引列上做任何操作，不能是表达式的一部分，不能是函数的参数，不包含隐式显式类型转换。

例如下面的查询不能使用 actor_id 列的索引：

```sql
SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
```

2.复合索引

需要用多个列进行条件查询时，复合索引比使用单值索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。

```sql
SELECT film_id, actor_ id FROM sakila.film_actor
WHERE actor_id = 1 AND film_id = 1;
```

复合索引必须遵循最左前缀匹配，否则无法使用复合索引。例如有索引(a,b,c)，如下SQL无法使用到该索引，只会用到(a)。

```sql
SELECT a FROM table WHERE a='a' and c='c'
```

3.索引列顺序

尽量让选择性高的列放在符合索引的前面。这里的选择性高指的是区分度高，即该列的distinct值多。

4.前缀索引

对于BLOB、TEXT和VARCHAR类型的列，必须使用前缀索引，建立索引时取这些属性的前缀作为索引。

前缀长度的选取需要根据索引选择性来确定。

5.覆盖索引

索引包含需要查询的所有字段。

- 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。
- 一些存储引擎（例如 MyISAM）在内存中只**缓存索引**，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。
- 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。

### 优点

- 大大减少了服务器需要扫描的数据行数。
- 帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。
- 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。

### 适用条件

- 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；
- 对于中到大型的表，索引就非常有效；
- 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。

## 查询性能优化

### Explain

使用 Explain 分析 SELECT 查询语句。

重要的字段有：

- type：访问类型（system>const>eq_ref>ref>range>index>ALL）
  - ALL：全表扫描index：全索引扫描，只遍历索引树
  - range：只检索给定范围的行，使用一个索引来选择行
  - ref：非唯一性索引扫描，返回匹配某个单独值的所有行
  - eq_ref：唯一索引扫描，对于每个索引键表中只有一条记录与之匹配
  - const：通过索引一次就查到
  - system：表中只有一行记录（等于系统表）
  - NULL
- key：使用的索引
- rows：扫描的行数

### 优化数据访问

#### 减少请求的数据量

- 只返回必要的列：最好不要使用 SELECT * 语句。
- 只返回必要的行：使用 LIMIT 语句来限制返回的数据。
- 缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。

#### 减少服务器端扫描的行数

使用覆盖索引

### 重构SQL查询

#### 切分大查询

一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。

```sql
DELETE FROM messages WHERE create < DATE_SUB(NOW(), INTERVAL 3 MONTH);
==================
rows_affected = 0
do {
    rows_affected = do_query(
    "DELETE FROM messages WHERE create  < DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000")
} while rows_affected > 0
```

#### 分解大连接

将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：

- 让**缓存**更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。
- 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。
- 减少锁竞争；
- 在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。
- 查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。

```sql
SELECT * FROM tag
JOIN tag_post ON tag_post.tag_id=tag.id
JOIN post ON tag_post.post_id=post.id
WHERE tag.tag='mysql';
```

```sql
SELECT * FROM tag WHERE tag='mysql';
SELECT * FROM tag_post WHERE tag_id=1234;
SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);
```

## 存储引擎

### InnoDB 

MySQL 默认**事务型**存储引擎。，只有在需要它不支持的特性时，才考虑使用其它存储引擎。

- 实现四个标准隔离级别。默认为RR，通过 MVCC + Next-Key Locking 避免幻读。
- 主索引为聚簇索引，即索引中保存了数据行，避免直接读取磁盘。
- 内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。
- 支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

### MyISAM

设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。提供了大量的特性，包括压缩表、空间数据索引等。

- 不支持事务。
- 不支持行锁，只有表锁，高并发场景下不适合。
- 可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。
- 如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。

### 比较

- 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
- 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
- 外键：InnoDB 支持外键。
- 缓存：InnoDB 既缓存索引也缓存真实数据，内存要求高，内存是影响性能的关键，而 MyISAM 只缓存索引。
- 备份：InnoDB 支持在线热备份。
- 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
- 其它特性：MyISAM 支持压缩表和空间数据索引。

## 切分

### 水平切分

水平切分又称为Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。

当一个表的数据不断增多时，Sharding可以将数据分布到集群的不同节点上，从而缓存单个数据库压力

![image-20210220161411956](C:\Users\aasus\AppData\Roaming\Typora\typora-user-images\image-20210220161411956.png)

### 垂直切分

垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。

在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。

![image-20210220161523592](C:\Users\aasus\AppData\Roaming\Typora\typora-user-images\image-20210220161523592.png)

### Sharding 策略

- 哈希取模：hash(key) % N；
- 范围：可以是 ID 范围也可以是时间范围；
- 映射表：使用单独的一个数据库来存储映射关系。

Sharding 存在的问题

1.事务问题

使用分布式事务解决，如XA接口。

2.连接

可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。

3.ID 唯一性

- 使用全局唯一 ID（GUID）
- 为每个分片指定一个 ID 范围
- 分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)

## 复制

### 主从复制

主要涉及三个线程： binlog 线程、 I/O 线程和 SQL 线程。

- binlog 线程：负责将主服务器上的数据更改写入二进制日志（Binary log）中。
- I/O 线程：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。
- SQL 线程：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。

![image-20210220162537506](C:\Users\aasus\AppData\Roaming\Typora\typora-user-images\image-20210220162537506.png)

### 读写分离

主服务器处理写操作以及实时性较高的读操作，从服务器处理读操作。

读写分离能够提高性能的原因在于：

- 主从服务器负责各自的读和写，极大地减缓了锁的争用。
- 从服务器可以使用 MyISAM， 提升查询性能以及节约系统开销。
- 增加冗余，高可用

读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。

![image-20210220162938740](C:\Users\aasus\AppData\Roaming\Typora\typora-user-images\image-20210220162938740.png)

# 面试题

## SQL 的执行过程

- 首先通过**连接器**登录数据库
- 如果是 SELECT 查询语句，会先去**查询缓存**中查找是否有缓存
- 如果缓存未命中，进入**分析器**
  - 词法分析：提取 SQL 中多个关键词，如查询的表，字段名，查询条件等
  - 语法分析：是否符合 SQL 语法
- **优化器**判断多个执行方案中哪个执行方案最优，选择最优方案执行。如多个索引之间如果选择，多表查询如何选择关联顺序等
- **执行器**调用存储引擎的接口，返回执行的结果


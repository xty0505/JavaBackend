# 数据库原理

## 事务

满足 ACID 特性的一组操作，通过 Commit 提交，Rollback 回滚。MySQL 默认采用自动提交模式。

### ACID

#### 1. 原子性（Atomicity）

事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。

回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

#### 2. 一致性（Consistency）

数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。

#### 3. 隔离性（Isolation）

一个事务所做的修改在最终提交以前，对其它事务是不可见的。

#### 4. 持久性（Durability）

一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。

系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。

## 并发一致性问题

主要原因是破坏了事务的隔离性，可以通过并发控制来保证隔离性。并发控制可以通过锁机制实现。DBMS一般都提供了可以设置的事务隔离级别，避免用户自己操作锁。

### 丢失修改

丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。

### 脏读

一个事务读取了另一个事务还未提交的数据。

### 不可重复读

一个事务内多次读某个数据，由于另一个事务对该数据进行了修改并提交，导致当前事务多次读取内容不同。

### 幻读

本质也是不可重复读的情况，只不过另一个事务进行的是插入操作，导致当前事务多次读取行数不同。

## 锁机制

### 锁粒度

MySQL 中提供两种锁粒度：行锁和表锁。

锁粒度越小，并发程度越高，系统开销越大。

### 锁类型

#### 读写锁

- 互斥锁，X锁，写锁
- 共享锁，S锁，读锁

对于写锁，一个事务对数据加了写锁，其操作期间其他事务不能对该数据进行任何加锁操作。

对于读锁，其他事物可以对该数据加读锁，不能加写锁。

#### 意向锁

使用意向锁（Intention Locks）可以更容易地支持多粒度锁。

在存在行锁和表锁的情况下，事务A想要对表加X锁，就需要检测是否有其他事务持有表锁或者行锁，需要对表中每一行进行检测十分耗时。

意向锁分为 IX/IS，都是表锁，表示某个事物想要在表中的某行加锁。

- 意向锁之间互相兼容，意向锁与**表级 X/S 锁不兼容**。
- 通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 IX/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。
- 但是意向锁**与行级 X/S 锁兼容**。例如事务 T1 对表 A 第1行加了X锁，事务 T2 想对 A 第2行加X锁，检测到 T1 持有 **IX 锁**，因为意向锁之间兼容，因此 T2 获取到 IX 锁， 因为 A 第2行上没有 X 锁，因此 T2 成功获取到了第2行的 X 锁。

意向锁的兼容关系如下图，X/S 都是表锁。

![image-20210219163927300](C:\Users\aasus\AppData\Roaming\Typora\typora-user-images\image-20210219163927300.png)

### 锁协议

#### 三级锁协议

##### 一级锁协议

事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。

可以解决**丢失修改**问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。

##### 二级锁协议

在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。

可以解决**读脏**数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。

##### 三级锁协议

在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。

可以解决**不可重复读**的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。

#### 两段锁协议

加锁和解锁分为两个阶段进行。

可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。

事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。

```
lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)
```

但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。

```
lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)
```

#### MySQL隐式与显示锁定

MySQL 的 InnoDB 存储引擎采用**两段锁协议**，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。

InnoDB 也可以使用特定的语句进行显示锁定：

```sql
SELECT ... LOCK In SHARE MODE;
SELECT ... FOR UPDATE;
```

### 隔离级别

![image-20210219165716102](C:\Users\aasus\AppData\Roaming\Typora\typora-user-images\image-20210219165716102.png)

## 多版本并发控制（MVCC）

多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现**提交读和可重复读**这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。

### 基本思想

利用多版本思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系。类似CopyOnWrite。

- 事务的增删改操作会为数据行新增一个版本快照。
- 事务的只能读取已提交的数据快照，但是可以读取事务本身未提交的快照。

### 版本号

- 系统版本号 SYS_ID: 递增的数字，每开始一个新的事务，SYS_ID 就会递增。
- 事务版本号 TRX_ID: 事务开始时的系统版本号。

### Undo 日志

MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。

例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。

```sql
INSERT INTO t(id, x) VALUES(1, "a");
UPDATE t SET x="b" WHERE id=1;
UPDATE t SET x="c" WHERE id=1;
```

INSERT、UPDATE、DELETE 操作会创建一个日志，并将 TRX_ID 写入。DELETE 可以看做特殊的 UPDATE 操作，会将日志中 DEL 字段置为1。

![image-20210219171233105](C:\Users\aasus\AppData\Roaming\Typora\typora-user-images\image-20210219171233105.png)

### ReadView

MVCC 维护了一个 ReadView 结构，主要包含了当前系统未提交的事务列表 TRX_IDs {TRX_ID_1, TRX_ID_2, ...}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX。

![image-20210219171426549](C:\Users\aasus\AppData\Roaming\Typora\typora-user-images\image-20210219171426549.png)

查询数据时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：

- TRX_ID < TRX_ID_MIN，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。
- TRX_ID > TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。
- TRX_ID_MIN <= TRX_ID <= TRX_ID_MAX，那就需要判断一下 trx_id 属性值是不是在 m_ids 列表中，如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。

在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。

Read Committed 和 Repeatable Read 的区别就在于 Read Committed 每次查询的时候生成一个 ReadView，而 Repeated Read 只在第一次查询时生成 Read View。 

### 快照读与当前读

#### 快照读

MVCC 的 SELECT 读取的是快照中的数据，不需要加锁。

#### 当前读

MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。

#### 快照读无法解决幻读

MVCC 不能解决幻读问题。例如事务 T1 和 事务 T2如下，事务 T1 在 for update 前后两次读取内容不同。原因在于 for update 相当于执行了 UPDATE 操作，更新了 T2 插入的快照数据的版本号为 T1 当前版本号，因此第二次 SELECT （**快照读**）能够查询到多出来的一行数据，产生了幻读。

```sql
start transaction
select * from t;
// 此时 T2 提交
select * from t for update; //当前读
select * from t; //快照读
commit;
```

```sql
start transaction;
insert into t values(2,'b');
commit;
```

## Next-Key Locks

Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。

MVCC 不能解决**幻影读问题**，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。

仍然是上面的幻读的例子，如果 T1 的每个 SELECT 查询都是 for update 即**当前读**，就会给相应记录的索引和其间隙加锁，这样 T2 就会被阻塞，直到 T1 的所有查询结束，T2 才会提交。这样 T1 的查询就不会出现幻读。

### Record Locks

锁定一个记录上的索引，而不是记录本身。

如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。

### Gap Locks

锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。

```sql
SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
```

### Next-Key Locks

它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：

```
(-∞, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +∞)
```

加锁规则有以下特性：

- 加锁的基本单位是（next-key lock）,他是前开后闭原则
- 插叙过程中访问的对象会增加锁
- 索引上的等值查询--给唯一索引加锁的时候，next-key lock 升级为行锁
- 索引上的等值查询--向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁
- 唯一索引上的范围查询会访问到不满足条件的第一个值为止

## 关系数据库设计理论

### 函数依赖

记 A->B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。

如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。

对于 A->B，如果能找到 A 的真子集 A'，使得 A'-> B，那么 A->B 就是部分函数依赖，否则就是完全函数依赖。

对于 A->B，B->C，则 A->C 是一个传递函数依赖。

### 异常

以下的学生课程关系的函数依赖为 {Sno, Cname} -> {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。

| Sno  | Sname  | Sdept  | Mname  | Cname  | Grade |
| ---- | ------ | ------ | ------ | ------ | ----- |
| 1    | 学生-1 | 学院-1 | 院长-1 | 课程-1 | 90    |
| 2    | 学生-2 | 学院-2 | 院长-2 | 课程-2 | 80    |
| 2    | 学生-2 | 学院-2 | 院长-2 | 课程-1 | 100   |
| 3    | 学生-3 | 学院-2 | 院长-2 | 课程-2 | 95    |

不符合范式的关系，会产生很多异常，主要有以下四种异常：

- 冗余数据：例如 `学生-2` 出现了两次。
- 修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。
- 删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 `课程-1` 需要删除第一行和第三行，那么 `学生-1` 的信息就会丢失。
- 插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。

### 范式

范式理论是为了解决以上提到四种异常。

高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。

#### 1. 第一范式 (1NF)

属性不可分。

#### 2. 第二范式 (2NF)

每个非主属性完全函数依赖于键码。

可以通过分解来满足。

**分解前**

| Sno  | Sname  | Sdept  | Mname  | Cname  | Grade |
| ---- | ------ | ------ | ------ | ------ | ----- |
| 1    | 学生-1 | 学院-1 | 院长-1 | 课程-1 | 90    |
| 2    | 学生-2 | 学院-2 | 院长-2 | 课程-2 | 80    |
| 2    | 学生-2 | 学院-2 | 院长-2 | 课程-1 | 100   |
| 3    | 学生-3 | 学院-2 | 院长-2 | 课程-2 | 95    |

以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：

- Sno -> Sname, Sdept
- Sdept -> Mname
- Sno, Cname-> Grade

Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。

Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。

**分解后**

关系-1

| Sno  | Sname  | Sdept  | Mname  |
| ---- | ------ | ------ | ------ |
| 1    | 学生-1 | 学院-1 | 院长-1 |
| 2    | 学生-2 | 学院-2 | 院长-2 |
| 3    | 学生-3 | 学院-2 | 院长-2 |

有以下函数依赖：

- Sno -> Sname, Sdept
- Sdept -> Mname

关系-2

| Sno  | Cname  | Grade |
| ---- | ------ | ----- |
| 1    | 课程-1 | 90    |
| 2    | 课程-2 | 80    |
| 2    | 课程-1 | 100   |
| 3    | 课程-2 | 95    |

有以下函数依赖：

- Sno, Cname -> Grade

#### 3. 第三范式 (3NF)

非主属性不传递函数依赖于键码。

上面的 关系-1 中存在以下传递函数依赖：

- Sno -> Sdept -> Mname

可以进行以下分解：

关系-11

| Sno  | Sname  | Sdept  |
| ---- | ------ | ------ |
| 1    | 学生-1 | 学院-1 |
| 2    | 学生-2 | 学院-2 |
| 3    | 学生-3 | 学院-2 |

关系-12

| Sdept  | Mname  |
| ------ | ------ |
| 学院-1 | 院长-1 |
| 学院-2 | 院长-2 |

# 面试题

## 数据库隔离级别，可重复读级别下如何解决幻读，间隙锁能够解决所有的幻读问题吗？间隙锁具体是如何实现的？

通过 MVCC 和 Next-Key Locks 解决。间隙锁用于解决当前读情况下的幻读问题。

默认情况下，InnoDB 工作在可重复读( Repeatable Read )隔离级别下，并且会以 Next-Key Lock 的方式对数据行进行加锁，这样可以有效防止幻读的发生。Next-Key Lock 是行锁和间隙锁的组合，当 InnoDB 扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。








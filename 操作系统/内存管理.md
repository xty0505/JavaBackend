# 内存管理

## 虚拟内存

虚拟内存目的是为了让物理内存扩充为更大的逻辑内存，从而能够运行多个程序。

操作系统将程序内存抽象为地址空间，物理内存的存储空间连续，被分为多个块(**页框**)。每个应用程序的地址空间也分为多个块(**页**)，每个页被映射到物理内存中，**不必连续**，**也不必所有页都存在于物理内存**。

当程序引用不再物理内存中的页时，需要从磁盘中将页映射到物理内存中，期间可能会替换某些页。

虚拟地址和物理地址的区别：

- 物理地址就是实际物理内存中的地址，连续；虚拟地址是进程对应的地址空间，未必连续，必须由 MMU 转换才能得到物理地址

## 页式存储管理

内存管理单元 (MMU) 管理着逻辑地址和物理地址的转换，其中的页表存储着页和页框的映射表。

虚拟地址：页号+页内偏移地址

物理地址：页表中页号对应的值+页内偏移地址

![image-20210208174047685](..\pic\image-20210208174047685.png)



## 页面置换算法

当程序运行时发现引用的页不在内存中，就会发生缺页中断从而将该页从磁盘调入内存，如果此时内存没有剩余空间，需要进行页面置换。

页面置换算法与缓存淘汰策略类似。目标是使页面置换频率最低

### 最佳(OPT)

所选择的换出页面时未来最长时间不会再被访问的页。是一种理论上的算法，无法得知某个页面多长时间不再被访问。

### 最近最久未使用(LRU)

LRU根据过去一段时间内的访问频率，将最久未被使用的页替换。

需要在内存中维护一个链表，当一个页被访问时，将该页移动到链表头。因此每次访问都需要更新链表，代价较高。

### 最近未使用(NRU)

每个页都有两个状态位R/M，分别代表是否被访问，是否被修改。R会被定时清零。

当发生缺页中断时，NRU算法会随机选择R/M为零的页置换。优先置换已经被修改的脏页(R=0,M=1)，而非频繁访问的干净页(R=1,M=0)

### 先进先出(FIFO)

优先选择最先进入的页面。

会将经常访问的页置换出去，导致缺页率升高。

### 第二次机会

FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：

当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。

![image-20210208193634103](..\pic\image-20210208193634103.png)

### 时钟

第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。

![image-20210208193741021](..\pic\image-20210208193741021.png)

## 段式存储管理

页式内存管理是一维的地址空间，段式内存管理将程序分成不同段，每个段构成一个独立的地址空间，每个段的长度不同，可以动态增长。

![image-20210208194528416](..\pic\image-20210208194528416.png)

![image-20210208194542619](..\pic\image-20210208194542619.png)



## 段页式

程序的地址空间划分为多个拥有独立地址空间的段，每个段上分页。

拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。

## 分段分页的比较

- 对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。
- 地址空间的维度：分页是一维地址空间，分段是二维的。
- 大小是否可以改变：页的大小不可变，段的大小可以动态改变。
- 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。
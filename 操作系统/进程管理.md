

# 进程管理

## 进程与线程

- 进程：资源分配的基本单位

  进程控制块(PCB)描述了进程的基本信息和运行状态，进程的创建和撤销都是对PCB的操作

- 线程：资源调度的基本单位

区别：

|         | 资源             | 系统开销 | 通信                               |
| ------- | ---------------- | -------- | ---------------------------------- |
| Process | 拥有             | 开销大   | IPC                                |
| Thread  | 不拥有，可以访问 | 开销小   | 同一进程内可以直接读写数据进行通信 |



进程上下文切换和线程上下文切换的区别：

- 进程上下文切换需要切换内存地址空间，而线程无需切换地址空间，因此进程上下文切换代价会更高

协程：子方法的执行能够被打断，然后转到另一个子方法上执行，执行完成后再返回原子方法执行。

- 协程可以认为是运行在线程上的代码块，协程提供的挂起操作会使协程暂停执行，而不会导致线程阻塞。
- 协程是用户态的并发机制，同一时刻只有一个协程在运行，其他协程挂起等待；相比进程切换和线程切换需要在内核态和用户态之间切换，协程切换不涉及内核，切换代价更小，更轻量级，适合 IO 密集型的场景。

## 进程调度算法

### 批处理系统

没有过多的用户操作，用户提交完作业后直到获得结果都不再和系统交互。调度算法的目标是保证吞吐量和周转时间

#### 先来先服务（First-Come First-Served）

非抢占式，按照请求的顺序进行调度。

短作业需要等待长作业执行完成才能执行，等待时间过长

#### 短作业优先（Shortest Job First）

非抢占式，按照作业估计运行时间最短的顺序进行调度

如果短作业一直加入，可能导致长作业饥饿

#### 最短剩余时间优先(Shortest Remaining Time Next)

SJF的抢占式版本，按剩余时间的顺序进行调度。当一个新作业到达时，其整个运行时间与当前进程的剩余时间比较，如果新进程的运行时间更少，则挂起当前线程，运行新的线程。

### 交互式系统

交互式系统存在大量用户交互操作，在该系统中调度算法的目标是为了快速进行相应

#### 时间盘轮转

将所有就绪进程按FCFS原则排成一个队列，每次调度时，把CPU时间分配个**队首进程**，该进程可以执行一个时间片。当时间片用完，由计时器发出**时钟中断**，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把CPU时间片分配给队首的进程

时间盘轮转算法的效率与**时间片大小**有很大关系：

- 进程切换需要保存进程信息并载入新进程的信息，时间片太小导致进程切换频繁，开销大
- 时间片太大导致不能及时响应每个进程

![image-20210203181429372](C:\Users\aasus\AppData\Roaming\Typora\typora-user-images\image-20210203181429372.png)

#### 优先级调度

为每个线程分配一个优先级，按优先级进行调度。

为了防止低优先级的进程饥饿，可以随着等待时间的推移增加等待进程的优先级

#### 多级反馈队列(时间片+优先级)

如果一个进程需要100个时间片执行完成，则在时间片轮转算法中它需要被调度100次。

多级队列考虑到了这种需要连续执行多个时间片的进程，设置了多个多列，每个队列时间片大小不同(如1,2,4,8)，进程在第一个时间片执行完成后进入第二队列，在这种方式下进程切换次数只有7次。

每级队列的优先级也有所不同，最上面的队列优先级最高。对于某一个队列，只有比它优先级高的队列中没有进程，才能调度该队列上的进程。

![image-20210203182328461](C:\Users\aasus\AppData\Roaming\Typora\typora-user-images\image-20210203182328461.png)

### 实时系统

要求请求在一个确定时间内得到响应。

## 进程同步

### 信号量(Semaphore)

- **down** : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；
- **up** ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。

down和up操作需要被设计为原语，不可分割，通常的做法是在执行down或up时屏蔽中断。

如果信号量只能为0或1，则成为互斥量（Mutex）

### 管程

信号量机制实现同步需要在客户端代码中做很多控制，而管程把控制的代码独立出来。 **管程结构确保了同时只能有一个进程在管程内活动** 。

管程引入条件变量condition以及相关的操作

- wait():导致进程阻塞，把管程让出给其他线程使用
- signal():唤醒被阻塞的进程

## 进程通信

### 管道

管道通过pipe函数创建，fd[0]用于读，fd[1]用于写

```c
#include <unistd.h>
int pipe(int fd[2]);
```

- 只支持半双工通信（单向交替传输）
- 只能在父子进程或者兄弟进程中使用

![image-20210204192825475](C:\Users\aasus\AppData\Roaming\Typora\typora-user-images\image-20210204192825475.png)

### 命名管道FIFO

去除了管道只能在父子进程中使用的限制

```c
#include <sys/stat.h>
int mkfifo(const char *path, mode_t mode);
int mkfifoat(int fd, const char *path, mode_t mode);
```

常用于客户-服务器应用程序中，FIFO用作汇聚点，在客户进程和服务器进程之间传递数据

![image-20210204193120391](C:\Users\aasus\AppData\Roaming\Typora\typora-user-images\image-20210204193120391.png)

### 消息队列

相比FIFO有以下优点

- 可独立于读写进程存在，避免了管道的打开和关闭
- 避免了FIFO的同步阻塞问题，不需要进程自己提供同步方法
- 读进程可以筛选消息，而不向FIFO只能默认接受

### 信号量

计数器，用于同步多个线程对共享数据的访问

### 共享存储

允许多个进程共享一段存储区，数据不需要在进程之间复制，最快的一种IPC。

需要一些方法同步进程

### Socket 套接字

可用于不同机器之间的进程通信